// src/routes/topics.js
import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs/promises';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const router = express.Router();

const ITEMS_PER_PAGE = 10;

// Helper to get the numeric value of a level
function getLevelNumber(level) {
    return parseInt(level.replace('Level ', '')) || 0;
}

// Helper to get previous level's problem count
async function getPreviousLevelsProblemCount(topicPath, currentLevel) {
    try {
        const files = await fs.readdir(topicPath);
        const allProblems = await Promise.all(
            files
                .filter(file => file.endsWith('.json'))
                .map(async (file) => {
                    const content = await fs.readFile(path.join(topicPath, file), 'utf8');
                    return JSON.parse(content);
                })
        );

        return allProblems.filter(p => getLevelNumber(p.level) < currentLevel).length;
    } catch (error) {
        console.error('Error counting previous problems:', error);
        return 0;
    }
}

async function getTopicProblems(topicName, options = {}) {
    const { page = 1, level = 'all', sort = 'level' } = options;
    const topicPath = path.join(__dirname, '../../MATH/train', topicName);
    
    try {
        console.log('Reading directory:', topicPath);
        const files = await fs.readdir(topicPath);
        
        // First, get all problems
        let problems = await Promise.all(
            files
                .filter(file => file.endsWith('.json'))
                .map(async (file) => {
                    const filePath = path.join(topicPath, file);
                    const content = await fs.readFile(filePath, 'utf8');
                    const problem = JSON.parse(content);
                    return {
                        ...problem,
                        id: path.basename(file, '.json'),
                        numericLevel: getLevelNumber(problem.level)
                    };
                })
        );

        // Sort all problems by level and then by ID
        problems.sort((a, b) => {
            if (a.numericLevel !== b.numericLevel) {
                return a.numericLevel - b.numericLevel;
            }
            return parseInt(a.id) - parseInt(b.id);
        });

        // Filter by level if specified
        let filteredProblems = problems;
        if (level !== 'all') {
            const numericLevel = parseInt(level);
            const previousCount = await getPreviousLevelsProblemCount(topicPath, numericLevel);
            
            filteredProblems = problems.filter(p => p.numericLevel === numericLevel);
            filteredProblems = filteredProblems.map((p, idx) => ({
                ...p,
                displayNumber: previousCount + idx + 1
            }));
        } else {
            filteredProblems = problems.map((p, idx) => ({
                ...p,
                displayNumber: idx + 1
            }));
        }

        // Get unique levels for the filter dropdown
        const uniqueLevels = [...new Set(problems.map(p => p.numericLevel))].sort((a, b) => a - b);

        // Calculate pagination
        const totalItems = filteredProblems.length;
        const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
        const currentPage = Math.max(1, Math.min(page, totalPages));
        const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
        const paginatedProblems = filteredProblems.slice(startIndex, startIndex + ITEMS_PER_PAGE);

        console.log('Paginated problems:', paginatedProblems.map(p => ({
            level: p.level,
            displayNumber: p.displayNumber
        })));

        return {
            problems: paginatedProblems,
            pagination: {
                currentPage,
                totalPages,
                totalItems,
                hasNextPage: currentPage < totalPages,
                hasPrevPage: currentPage > 1
            },
            filters: {
                currentLevel: level,
                availableLevels: uniqueLevels,
                currentSort: sort
            }
        };
    } catch (error) {
        console.error(`Error reading problems for topic ${topicName}:`, error);
        return {
            problems: [],
            pagination: {
                currentPage: 1,
                totalPages: 0,
                totalItems: 0,
                hasNextPage: false,
                hasPrevPage: false
            },
            filters: {
                currentLevel: level,
                availableLevels: [],
                currentSort: sort
            }
        };
    }
}

router.get('/:topicName', async (req, res) => {
    const { topicName } = req.params;
    const { page = 1, level = 'all', sort = 'level' } = req.query;

    try {
        const { problems, pagination, filters } = await getTopicProblems(topicName, {
            page: parseInt(page),
            level,
            sort
        });
        
        res.render('topic', {
            title: topicName.replace(/_/g, ' ')
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' '),
            topicName,
            problems,
            pagination,
            filters,
            currentUrl: `/topics/${topicName}`,
            query: req.query
        });
    } catch (error) {
        console.error('Error loading topic:', error);
        res.status(500).render('error', {
            message: 'Error loading topic'
        });
    }
});

export default router;